# Operating Systems and System Programming. Laboratory Work №1

### Задание

Необходимо разработать приложение на базе `Win32` с использованием языка программирования `C++`, которое позволит пользователю управлять движением некоторого объекта на форме с помощью стрелок клавиатуры, а также левой и правой кнопками мыши. Также, ситуация с выходом обьекта за пределы формы должна быть предотвращена (например, отскоком от границ формы).

## Решение

### Представление формы с объектом

![1](https://user-images.githubusercontent.com/55713244/189618316-46b8b667-a277-4f34-8709-0cbf36aa0d12.jpg)

### Немного о реализации оконного класса и всего, что с ним связано 

Для начала, было созданно само `окно`, которое и будет являться тем местом, откуда будут `фиксироваться` действия пользователя. Была добавлена процедура `WindowProc`, которая призвана `отследить нажатия на клавиши` и `менять соответствующие характеристики движения` нашего объекта. Как только мы получили информацию о событии и определили, куда необходимо двигать наш объект, мы должны произвести соответствующие изменения:
1) `Поменять координаты текущего объекта`, ссылаясь на полученную информацию о движении объекта (тут и будут проверяться все возможные проблемы, возникаемые при выходе объекта за границу).
2) `Обновить оконный класс` (в моём случае, я использовал банальную закраску оконного класса в цвет самого окна, чтоб избежать возможных задержек при повторном создании и регистрации оконного класса).
3) `Отрисовать объект заново`, но уже с новыми координатами, в оконном классе

### Теперь про техническую часть

#### Поменять координаты текущего объекта

В программе, за движение объекта по различным напрвлениям отвечают следующие переменные: `moving_left`, `moving_right`, `moving_up` и `moving_down`, принимающие либо `1`, либо `0` в качестве своих значений. Не трудно догадаться, что `смещением объекта` при единичном нажатии на клавишу `будет являться ширина` либо `высота` нашего перемещаемого объекта (зависит от того, в каком направлении мы двигаем сам объект). То есть, `получив информацию о направлении`, мы проверками `сможем определить`, в какую именно сторону объект `нужно двигать`, и его новые значения `width` и `height` будут вычиляться как `new_width` = `current_width` +- `object_width` и `new_height` = `current_height` +- `object_height` соответственно. 

#### Движение объекта и его скорость

За скорость объекта в программе отвечает переменная `speed`, которая хранит в себе `множитель`, на который будут домножены соответствующие значения в программе для иллюстрации `более быстрого` движения самого объекта. В ходе разработки, `была выялвена следующая проблема`: При одновременном движении объекта вдоль оси `Ox` и `Oy`, его `скорость движения выше`, нежели при движении вдоль `одной из них`. Эта проблема вытекает из того, что `результирующий вектор` будет вычисляться как `корень из суммы квадратов катетов`, которые определяют движение вдоль одной из осей. Таким образом, в ходе небольших математических преобразований, `выразив значение катета через гипотенузу`, было получено значение `0.707` (или же `корень из 1/2`), на которое необходимо `домножить` скорость движения объекта, чтобы получить скорость движения, схожую с движением `только вдоль одной оси`. 

#### Проверка выхода перемещаемого объекта за границы оконного класса

За `ширину` и `высоту` оконного класса в программе отвечают переменные `client_width` и `client_height`, которые призваны помочь нам отследить `выход за границы` оконного класса. Дело в том, что если `сумма текущей координаты` x или y с `шириной или высотой перемещаемого объекта` будет давать `результат больше`, чем `ширина или высота` оконного класса, то это `будет означать`, что объект `выходит за рамки оконного класса`. При обнаружении программой такого случая, предусмотрена `инверсия`, то есть, если объект должен был `двигаться вверх` - его `новым направлением` будет являться `движение вниз`, тоже самое с `движением вправо` и `влево` соответственно. Таким образом, получилось не только создать `анимацию` своего рода `отскока от границы`, но и `предотвратить возможные ошибки`, возникаемые в случае `выхода за пределы оконного класса`.
